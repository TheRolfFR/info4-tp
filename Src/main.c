/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Claussspe license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stm32f4xx.h>
#include "system.h"
#include <string.h>
#include "usart.h"

extern uint32_t scheduler;
extern uint32_t SystemCoreClock;
extern volatile struct TCB_t * current_tcb;

#define STACK_SIZE 500
typedef struct _task {
	uint32_t stack[STACK_SIZE];
	volatile TCB tcb;
} Task_t;

#define INDEX_EXEC_RETURN 0
#define INDEX_CONTROL 1
#define INDEX_RETURNADDR 16
#define INDEX_XPSR 17

volatile Task_t tasks[3];
volatile void* functions[3];

/**
 * @brief initialise la task avec le TCB suivant et la fonction de démarrage
 * @param[in] t La structure tache à initialiser
 * @param next Le TCB suivant
 * @param fun Adresse de la fonction à lancer au démarrage
 */
void task_init(volatile Task_t *t, volatile TCB* next, volatile void* fun) {
	// on fait le plus facile on lie le suivant et on pose le stack
	t->tcb.next = next;
	t->tcb.stack = &(t->stack[STACK_SIZE - 18]);

	// exec return mode : Thread = 0xFFFFFFFD donc pile PSP
	t->tcb.stack[INDEX_EXEC_RETURN] = 0xFFFFFFFD;

	// CONTROL : mode d'ouverture 2=privilégié, 3=non priviligié
	t->tcb.stack[INDEX_CONTROL] = (uint32_t) 3;

	// specific xpsr value
	t->tcb.stack[INDEX_XPSR] = 0x01000000;

	memset((uint8_t*) &(t->tcb.stack[2]), 0, 14*sizeof(uint32_t));

	// on met la fonction ici
	t->tcb.stack[INDEX_RETURNADDR] = (uint32_t) fun;
}

#define GPIO_LED GPIOA
#define GPIO_PIN_LED 5

void blink_init() {
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;

	// PA5 sortie : 01
	GPIO_LED->MODER &= ~(0b11 << (GPIO_PIN_LED * 2));
	GPIO_LED->MODER |= (0b1 << (GPIO_PIN_LED * 2));
}

uint32_t max1 = 100000;
uint32_t max2 = 300000;
uint32_t max  = 100000;

void task_yield() {
	SCB->ICSR = SCB_ICSR_PENDSVSET_Msk;
}

void enter_critical() {
	scheduler = 0;
}

void exit_critical() {
	scheduler = 1;
}

void blink_loop() {
	uint32_t counter = 0;

	while(1) {
		if(counter < max) {
			++counter;
		} else {
			uint8_t newLedState = ! (GPIO_LED->ODR & (1 << GPIO_PIN_LED));
			GPIO_LED->ODR &= (~(1 << GPIO_PIN_LED));
			GPIO_LED->ODR |= (newLedState << GPIO_PIN_LED);
			counter = 0;
		}
	}
}

#define GPIO_BUTTON GPIOC
#define GPIO_PIN_BUTTON 13

void button_init() {
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOCEN;

	// PC13 entrée
	GPIO_TypeDef* gpioc = GPIO_BUTTON;
	gpioc->MODER &= ~(0b11 << (GPIO_PIN_BUTTON * 2)); // in : 00
}

void button_loop() {
	// compteurs de debounce
	uint32_t debounce = 250000;
	uint32_t decounceCounter = debounce;

	for(;;) {
		if(decounceCounter < debounce) {
			++decounceCounter;
		} else {
			// le user button est en pull-up donc s'il est appuyé, sa valeur vaut 0
			if((GPIO_BUTTON->IDR & (1 << GPIO_PIN_BUTTON)) == 0) {
				max = (max == max1) ? max2 : max1;

				char chaine[] = "Bouton appuyé\r\n";
				USART2_Transmit((uint8_t*) chaine, strlen(chaine) + 1);

				decounceCounter = 0;
			}
		}
	}
}

void usart_init() {
	USART2_Init(115200);
}

void usart_loop() {
	uint32_t counter;
	char chaine[] = "Heartbeat : Je suis vivant !\r\n";
	while(1) {
		USART2_Transmit((uint8_t*) chaine, strlen(chaine) + 1);

		counter = 0;
		while(counter < max2) {
			++counter;
		}
	}
}

int main(void)
{
	// j'initialise toutes mes taches
	blink_init();
	button_init();
	usart_init();

	// je met mes fonctions dans un tableau pour écrire le round robin plus facilement
	functions[0] = blink_loop;
	functions[1] = button_loop;
	functions[2] = usart_loop;

	// j'initiaise toutes les structures tache
	for(uint8_t i = 0; i < 3; ++i) {
		task_init(&(tasks[i]), &(tasks[(i+1)%3].tcb), functions[i]);
	}

	// je prend le premier tcb pour le current tcb
	current_tcb = &(tasks[0].tcb);

	// Si vous voulez tester avec une seule tache
//	tasks[0].tcb.next = &(tasks[0].tcb);

	// On met les priorité et on active pendingSV
	NVIC_SetPriority (PendSV_IRQn, 15);
	NVIC_EnableIRQ (PendSV_IRQn);

	// on démarre la clock avec déclenchement de 10ms
	SysTick_Config(SystemCoreClock / 10000);

	// on lance la première tache et on active le scheduler
	SVC(0);

	// on ne devrait jamais venir ici normalement
	while(1) {
		__NOP();
	}
}
